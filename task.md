## Инструкция по работе с git ##
![error](123.jpg)

ОПИСАНИЕ
Git — это быстрая, масштабируемая, распределенная система контроля версий с необычайно богатым набором команд, обеспечивающим как высокоуровневые операции, так и полный доступ к внутренним компонентам.

Опции:

--version

Выводит версию пакета Git, из которой была создана программа git .

Эта опция внутренне преобразована git version ...и принимает те же опции, что и команда git-version(1) . Если --helpтакже задано, оно имеет приоритет над --version.

--help

Распечатывает краткий обзор и список наиболее часто используемых команд. Если указана опция --allили -a, то печатаются все доступные команды. Если команда Git названа, эта опция откроет справочную страницу для этой команды.

Доступны и другие параметры для управления отображением справочной страницы. См. git-help(1) для получения дополнительной информации, потому что git --help ...он внутренне преобразуется в файлы git help ....

-C path

Запускайте так, как если бы git был запущен в path вместо текущего рабочего каталога. Когда -Cзадано несколько вариантов, каждый последующий неабсолютный -C path интерпретируется относительно предыдущего -C path. Если path присутствует, но пуст, например -C "", , то текущий рабочий каталог остается неизменным.

Этот параметр влияет на параметры, которые ожидают имя пути, подобное --git-dir тому --work-tree, что их интерпретации имен путей будут сделаны относительно рабочего каталога, вызванного -Cпараметром. Например, следующие вызовы эквивалентны:

git --git-dir=a.git --work-tree=b -C c status git --git-dir=c/a.git --work-tree=c/b status

-c name=value

Передайте параметр конфигурации команде. Заданное значение переопределит значения из файлов конфигурации. Ожидается, что <имя> будет иметь тот же формат, что указан в git config (подключи разделены точками).

Обратите внимание, что пропуск =in git -c foo.bar ...разрешен и устанавливает foo.barлогическое значение true (точно так же, как [foo]barв файле конфигурации). Включая равные, но с пустым значением (например git -c foo.bar= ...), устанавливает foo.barпустую строку, которая git config --type=bool будет преобразована в false.

--config-env=name=envvar

Например -c name=value, присвойте переменной конфигурации name значение, где envvar — это имя переменной среды, из которой нужно получить значение. В отличие от -cотсутствия ярлыка для прямой установки значения в пустую строку, вместо этого сама переменная среды должна быть установлена ​​​​в пустую строку. Это ошибка, если envvar не существует в среде. envvar не может содержать знак равенства, чтобы избежать двусмысленности с name его содержанием.

Это полезно в случаях, когда вы хотите передать промежуточные параметры конфигурации в git, но делаете это в ОС, где другие процессы могут читать вашу командную строку (например /proc/self/cmdline), но не вашу среду (например /proc/self/environ). Это поведение по умолчанию в Linux, но может быть не в вашей системе.

Обратите внимание, что это может повысить безопасность для переменных, например, http.extraHeader когда конфиденциальная информация является частью значения, но не, например, url.base.insteadOfкогда конфиденциальная информация может быть частью ключа.

--exec-path[=path]

Путь к тому месту, где установлены ваши основные программы Git. Это также можно контролировать, установив переменную среды GIT_EXEC_PATH. Если путь не указан, git напечатает текущую настройку и затем завершит работу.

--html-path

Выведите путь без косой черты в конце, где установлена ​​HTML-документация Git, и выйдите.

--man-path

Распечатайте manpath ( main1 )для справочных страниц для этой версии Git и выйдите.

--info-path

Распечатайте путь, по которому установлены файлы Info, документирующие эту версию Git, и выйдите.

-p --paginate

Направить весь вывод в less (или, если установлено, в $PAGER), если стандартный вывод — это терминал. Это переопределяет параметры pager.cmd конфигурации.

-P --no-pager

Не направляйте вывод Git на пейджер.

--git-dir=path

Укажите путь к репозиторию (каталог ".git"). Это также можно контролировать, установив GIT_DIR переменную среды. Это может быть абсолютный или относительный путь к текущему рабочему каталогу.

Указание местоположения каталога «.git» с помощью этой опции (или GIT_DIR переменной среды) отключает обнаружение репозитория, которое пытается найти каталог с подкаталогом «.git» (именно так репозиторий и верхний уровень рабочего дерева обнаружены) и сообщает Git, что вы находитесь на верхнем уровне рабочего дерева. Если вы не находитесь в каталоге верхнего уровня рабочего дерева, вы должны сообщить Git, где находится верхний уровень рабочего дерева, с помощью --work-tree=path параметра (или GIT_WORK_TREE переменной среды)

Если вы просто хотите запустить git, как если бы он был запущен, path используйте git -C path.

--work-tree=path

Задайте путь к рабочему дереву. Это может быть абсолютный путь или путь относительно текущего рабочего каталога. Это также можно контролировать, задав переменную окружения GIT_WORK_TREE и переменную конфигурации core.worktree ( более подробное обсуждение см. в разделе core.worktree в git-config(1) ).

--namespace=path

Установите пространство имен Git.Эквивалентно установке GIT_NAMESPACE переменной среды.

--super-prefix=path

В настоящее время только для внутреннего использования. Установите префикс, который указывает путь сверху репозитория до его корня. Одним из способов использования является предоставление подмодулям контекста суперпроекта, который его вызвал.

--bare

Относитесь к репозиторию как к голому репозиторию. Если среда GIT_DIR не задана, она устанавливается в текущий рабочий каталог.

--no-replace-objects

Не используйте замену ссылок для замены объектов Git. См. git-replace(1) для получения дополнительной информации.

--literal-pathspecs

Обращайтесь с путевыми спецификациями буквально (т. е. без подстановок, без магии путей). Это эквивалентно установке GIT_LITERAL_PATHSPECS переменной среды в 1.

--glob-pathspecs

Добавьте магию "glob" ко всем путям. Это эквивалентно установке GIT_GLOB_PATHSPECS переменной среды в 1. Отключение подстановки для отдельных спецификаций пути можно выполнить с помощью магии спецификаций пути «: (буквальный)»

--noglob-pathspecs

Добавьте «буквальную» магию ко всем путям. Это эквивалентно установке GIT_NOGLOB_PATHSPECS переменной среды в 1. Включение подстановки для отдельных спецификаций пути может быть выполнено с помощью магии спецификаций пути ":(glob)"

--icase-pathspecs

Добавьте магию "icase" ко всем путям. Это эквивалентно установке GIT_ICASE_PATHSPECS переменной среды в 1.

--no-optional-locks

Не выполняйте необязательные операции, требующие блокировки. Это эквивалентно установке GIT_OPTIONAL_LOCKSto 0.

--list-cmds=group[,group…​]

Список команд по группам. Это внутренняя/экспериментальная опция, которая может быть изменена или удалена в будущем. Поддерживаемые группы: встроенные, parseopt (встроенные команды, использующие параметры разбора), main (все команды в каталоге libexec), другие (все остальные команды в $PATHкаталоге с префиксом git-), list-category (см. категории в command- list.txt), nohelpers (исключить вспомогательные команды), alias и config (получить список команд из переменной конфигурации complete.commands)

Начало работы с репозиторием
git init

создает локальный репозиторий
Если не было задано имя пользовыателя ранее, то:

git config --global user.name "name"

git config --global user.email "mail@mail.com"

Добавление файлов в репозиторий
git add file_name

Добавляет файл file_name для отслеживания

git commit -m "some message"

Фиксирует все файлы, которые были добавлены для отслеживания

![]file_name

Добавление картинки.

Отслеживание состояния репозитория
git status

Показывает измененные файлы и файлы готовые для коммита

get log

Для визуализации веток добавляйте тег:

get log --help

Показывает все коммиты

git diff

Показывает разницу между текущей версией и зафиксированной

Переход между коммитами
git checkout commit_code

Переходит к коммиту с кодом commit_code(его можно подсмотреть по git log)

git checkout master

Вернуться к акутальному состоянию

Ветки в git
Чтобы посмотреть все ветки:

git branch

Для создания ветки branch_name:

git branch "new branch"

Также можно использовать:

git checkout -b|-B "new branch"

>-b branch_name

>-B branch_name

Другие опции
start_point

Имя коммита, с которого начинается новая ветка. По умолчанию HEAD.

Как частный случай, вы можете использовать "A...B" в качестве ярлыка для базы слияния A и B если существует ровно одна база слияния. Вы можете опустить не более одного из A и B, и в этом случае по умолчанию используется значение HEAD.

>tree-ish

Дерево для оформления заказа (если заданы пути). Если не указано, будет использоваться индекс.

Как частный случай, вы можете использовать "A...B" в качестве ярлыка для базы слияния A и B если существует ровно одна база слияния. Вы можете опустить не более одного из A и B, и в этом случае по умолчанию используется значение HEAD.

>--

Не интерпретируйте больше аргументы как опции.

>pathspec

Ограничивает пути, затронутые операцией.

Переместиться к ветке:

>git checkout branch_name

Удаление и восстановление веток
Для удаления ветки игнорируя все ошибки:

>git branch -D branch_name

Где -D обозначает delete

Для восстановления ветки:

>git-restore

Восстановить указанные пути в рабочем дереве с некоторым содержимым из источника восстановления. Если путь отслеживается, но не существует в источнике восстановления, он будет удален, чтобы соответствовать источнику.

Команду также можно использовать для восстановления содержимого индекса с помощью --staged, или для восстановления рабочего дерева и индекса с помощью --staged --worktree.

>-s

>--source=

Восстановите файлы рабочего дерева с содержимым из данного дерева. Обычно исходное дерево указывается путем присвоения имени коммиту, ветке или тегу, связанному с ним.

Если не указано, содержимое восстанавливается из HEAD, если --staged указано, иначе из индекса.

Как частный случай, вы можете использовать "A...B" в качестве ярлыка для базы слияния A и B если существует ровно одна база слияния. Вы можете опустить не более одного из A и B, и в этом случае по умолчанию используется значение HEAD.

>-p

>--patch

В интерактивном режиме выберите фрагменты в разнице между источником восстановления и местом восстановления.

Обратите внимание, что --patch не может принимать пути и предложит восстановить все измененные пути.

>-W

>--worktree

>-S

>--staged

Укажите место восстановления. Если ни одна из опций не указана, по умолчанию восстанавливается рабочее дерево. Указание --staged приведет только к восстановлению индекса. Указание обоих восстанавливает оба.

>-q

>--quiet

Тихо, подавляйте сообщения обратной связи. Подразумевает --no-progress.

>--progress --no-progress

Статус выполнения сообщается в стандартном потоке ошибок по умолчанию, когда он подключен к терминалу, если --quiet не указано иное. Этот флаг включает отчеты о ходе работы, даже если они не подключены к терминалу, независимо от --quiet.

>--ours

>-theirs

При восстановлении файлов в рабочем дереве из индекса используйте этап №2 ( ours ) или №3 ( theirs ) для неслитных путей.

Обратите внимание, что во время и git rebase ours и theirs могут поменяться местами.

По умолчанию, если --staged указано, содержимое восстанавливается из HEAD, иначе из индекса. Используйте --source для восстановления из другого коммита.

>Примеры:

Следующая последовательность переключается на master ветку, возвращает Makefile две ревизии назад, удаляет hello.c по ошибке и возвращает его из индекса.

>git switch master

>git restore --source master~2 Makefile

>rm -f hello.c

>git restore hello.c

взять файл из другого коммита

восстановить hello.c из индекса

Если вы хотите восстановить все исходные файлы C, чтобы они соответствовали версии в индексе, вы можете сказать

>git restore '.c'*

Обратите внимание на кавычки вокруг *.c. Файл hello.cтакже будет восстановлен, даже если его больше нет в рабочем дереве, потому что подстановка файлов используется для сопоставления записей в индексе (а не в рабочем дереве оболочкой).

Чтобы восстановить все файлы в текущем каталоге

>git restore

или восстановить все рабочие файлы дерева с помощью магии top pathspec

>git restore :/

Чтобы восстановить файл в индексе, чтобы он соответствовал версии в HEAD(это то же самое, что использовать git-reset(1) )

>git restore --staged hello.c

или вы можете восстановить как индекс, так и рабочее дерево (это то же самое, что использовать git-checkout(1) )

>git restore --source=HEAD --staged --worktree hello.c

или короткая форма, которая более практична, но менее удобочитаема:

>git restore -s@ -SW hello.c

Слияние веток и решение конфликтов
Команда для выкачивания информации из ветки branch_name в текущую ветку:

>git merge branch_name

Для того что бы решить merge конфликт, нужно убрать лишние строки и отредактировать текст

*Справка*

Что бы вызвать справку для какой-то команды, нужно добавить тег:

--help

Примеры:

>git add --help

>git commit --help

>git commit --help

Создание таблицы

Столбец_1|Столбец_2|Столбец_3
Данные_1|Данные_2|Данные_3
Данные_1|Данные_2|Данные_3