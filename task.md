# Инструкция по работе с git 

![error](123.jpg)

## ОПИСАНИЕ

Git — это быстрая, масштабируемая, распределенная система контроля версий с необычайно богатым набором команд, обеспечивающим как высокоуровневые операции, так и полный доступ к внутренним компонентам.

Опции:

>--version

Выводит версию пакета Git, из которой была создана программа git .

Эта опция внутренне преобразована git version ...и принимает те же опции, что и команда git-version(1) . Если --helpтакже задано, оно имеет приоритет над --version.

>--help

Распечатывает краткий обзор и список наиболее часто используемых команд. Если указана опция --allили -a, то печатаются все доступные команды. Если команда Git названа, эта опция откроет справочную страницу для этой команды.

Доступны и другие параметры для управления отображением справочной страницы. См. git-help(1) для получения дополнительной информации, потому что git --help ...он внутренне преобразуется в файлы git help ....

>-C path

Запускайте так, как если бы git был запущен в path вместо текущего рабочего каталога. Когда -Cзадано несколько вариантов, каждый последующий неабсолютный -C path интерпретируется относительно предыдущего -C path. Если path присутствует, но пуст, например -C "", , то текущий рабочий каталог остается неизменным.

Этот параметр влияет на параметры, которые ожидают имя пути, подобное --git-dir тому --work-tree, что их интерпретации имен путей будут сделаны относительно рабочего каталога, вызванного -Cпараметром. Например, следующие вызовы эквивалентны:

git --git-dir=a.git --work-tree=b -C c status
git --git-dir=c/a.git --work-tree=c/b status

>-c name=value

Передайте параметр конфигурации команде. Заданное значение переопределит значения из файлов конфигурации. Ожидается, что <имя> будет иметь тот же формат, что указан в git config (подключи разделены точками).

Обратите внимание, что пропуск =in git -c foo.bar ...разрешен и устанавливает foo.barлогическое значение true (точно так же, как [foo]barв файле конфигурации). Включая равные, но с пустым значением (например git -c foo.bar= ...), устанавливает foo.barпустую строку, которая git config --type=bool будет преобразована в false.

>--config-env=name=envvar

Например -c name=value, присвойте переменной конфигурации name значение, где envvar — это имя переменной среды, из которой нужно получить значение. В отличие от -cотсутствия ярлыка для прямой установки значения в пустую строку, вместо этого сама переменная среды должна быть установлена ​​​​в пустую строку. Это ошибка, если envvar не существует в среде. envvar не может содержать знак равенства, чтобы избежать двусмысленности с name его содержанием.

Это полезно в случаях, когда вы хотите передать промежуточные параметры конфигурации в git, но делаете это в ОС, где другие процессы могут читать вашу командную строку (например /proc/self/cmdline), но не вашу среду (например /proc/self/environ). Это поведение по умолчанию в Linux, но может быть не в вашей системе.

Обратите внимание, что это может повысить безопасность для переменных, например, http.extraHeader когда конфиденциальная информация является частью значения, но не, например, url.base.insteadOfкогда конфиденциальная информация может быть частью ключа.

>--exec-path[=path]

Путь к тому месту, где установлены ваши основные программы Git. Это также можно контролировать, установив переменную среды GIT_EXEC_PATH. Если путь не указан, git напечатает текущую настройку и затем завершит работу.

>--html-path

Выведите путь без косой черты в конце, где установлена ​​HTML-документация Git, и выйдите.

>--man-path

Распечатайте manpath ( main1 )для справочных страниц для этой версии Git и выйдите.

>--info-path

Распечатайте путь, по которому установлены файлы Info, документирующие эту версию Git, и выйдите.

>-p
>--paginate

Направить весь вывод в less (или, если установлено, в $PAGER), если стандартный вывод — это терминал. Это переопределяет параметры pager.cmd конфигурации.

>-P
>--no-pager

Не направляйте вывод Git на пейджер.

>--git-dir=path

Укажите путь к репозиторию (каталог ".git"). Это также можно контролировать, установив GIT_DIR переменную среды. Это может быть абсолютный или относительный путь к текущему рабочему каталогу.

Указание местоположения каталога «.git» с помощью этой опции (или GIT_DIR переменной среды) отключает обнаружение репозитория, которое пытается найти каталог с подкаталогом «.git» (именно так репозиторий и верхний уровень рабочего дерева обнаружены) и сообщает Git, что вы находитесь на верхнем уровне рабочего дерева. Если вы не находитесь в каталоге верхнего уровня рабочего дерева, вы должны сообщить Git, где находится верхний уровень рабочего дерева, с помощью --work-tree=path параметра (или GIT_WORK_TREE переменной среды)

Если вы просто хотите запустить git, как если бы он был запущен, path используйте git -C path.

>--work-tree=path

Задайте путь к рабочему дереву. Это может быть абсолютный путь или путь относительно текущего рабочего каталога. Это также можно контролировать, задав переменную окружения GIT_WORK_TREE и переменную конфигурации core.worktree ( более подробное обсуждение см. в разделе core.worktree в git-config(1) ).

>--namespace=path

Установите пространство имен Git.Эквивалентно установке GIT_NAMESPACE переменной среды.

>--super-prefix=path

В настоящее время только для внутреннего использования. Установите префикс, который указывает путь сверху репозитория до его корня. Одним из способов использования является предоставление подмодулям контекста суперпроекта, который его вызвал.

>--bare

Относитесь к репозиторию как к голому репозиторию. Если среда GIT_DIR не задана, она устанавливается в текущий рабочий каталог.

>--no-replace-objects

Не используйте замену ссылок для замены объектов Git. См. git-replace(1) для получения дополнительной информации.

>--literal-pathspecs

Обращайтесь с путевыми спецификациями буквально (т. е. без подстановок, без магии путей). Это эквивалентно установке GIT_LITERAL_PATHSPECS переменной среды в 1.

>--glob-pathspecs

Добавьте магию "glob" ко всем путям. Это эквивалентно установке GIT_GLOB_PATHSPECS переменной среды в 1. Отключение подстановки для отдельных спецификаций пути можно выполнить с помощью магии спецификаций пути «: (буквальный)»

>--noglob-pathspecs

Добавьте «буквальную» магию ко всем путям. Это эквивалентно установке GIT_NOGLOB_PATHSPECS переменной среды в 1. Включение подстановки для отдельных спецификаций пути может быть выполнено с помощью магии спецификаций пути ":(glob)"

>--icase-pathspecs

Добавьте магию "icase" ко всем путям. Это эквивалентно установке GIT_ICASE_PATHSPECS переменной среды в 1.

>--no-optional-locks

Не выполняйте необязательные операции, требующие блокировки. Это эквивалентно установке GIT_OPTIONAL_LOCKSto 0.

>--list-cmds=group[,group…​]

Список команд по группам. Это внутренняя/экспериментальная опция, которая может быть изменена или удалена в будущем. Поддерживаемые группы: встроенные, parseopt (встроенные команды, использующие параметры разбора), main (все команды в каталоге libexec), другие (все остальные команды в $PATHкаталоге с префиксом git-), list-category (см. категории в command- list.txt), nohelpers (исключить вспомогательные команды), alias и config (получить список команд из переменной конфигурации complete.commands)


## Начало работы с репозиторием
>git init

* создает локальный репозиторий 

Если не было задано имя пользовыателя ранее, то:
>git config --global user.name "name"

>git config --global user.email  "mail@mail.com"

## Добавление файлов в репозиторий 
> git add file_name

Добавляет файл file_name для отслеживания

> git commit -m "some message"

Фиксирует все файлы, которые были добавлены для отслеживания

>![]file_name

Добавление картинки.

## Отслеживание состояния репозитория 
> git status

Показывает измененные файлы и файлы готовые для коммита
> get log

Для визуализации веток добавляйте тег:
>get log --help

Показывает все коммиты
> git diff

Показывает разницу между текущей версией и зафиксированной 

## Переход между коммитами
> git checkout commit_code

Переходит к коммиту с кодом commit_code(его можно подсмотреть по git log)

> git checkout master

Вернуться к акутальному состоянию


## Ветки в git

Чтобы посмотреть все ветки:

>git branch 

Для создания ветки branch_name:

>git branch "new branch"

Также можно использовать:

>git checkout -b|-B "new branch"

>*-b branch_name*

>*-B branch_name*

## Другие опции

>*start_point*

Имя коммита, с которого начинается новая ветка. По умолчанию *HEAD*.

Как частный случай, вы можете использовать *"A...B"* в качестве ярлыка для базы слияния *A и B* если существует ровно одна база слияния. Вы можете опустить не более одного из *A и B*, и в этом случае по умолчанию используется значение *HEAD*.


>*tree-ish*

Дерево для оформления заказа (если заданы пути). Если не указано, будет использоваться индекс.

Как частный случай, вы можете использовать *"A...B"* в качестве ярлыка для базы слияния *A и B* если существует ровно одна база слияния. Вы можете опустить не более одного из *A и B*, и в этом случае по умолчанию используется значение *HEAD*.


> *--*

Не интерпретируйте больше аргументы как опции.


>*pathspec*

Ограничивает пути, затронутые операцией.

Переместиться к ветке:

>git checkout branch_name

## Удаление и восстановление веток

Для удаления ветки игнорируя все ошибки:

>git branch -D branch_name

>Где -D обозначает delete

Для восстановления ветки:

>git-restore

Восстановить указанные пути в рабочем дереве с некоторым содержимым из источника восстановления. Если путь отслеживается, но не существует в источнике восстановления, он будет удален, чтобы соответствовать источнику.

Команду также можно использовать для восстановления содержимого индекса с помощью --staged, или для восстановления рабочего дерева и индекса с помощью --staged --worktree.

>*-s <tree>*

>*--source=<tree>*

Восстановите файлы рабочего дерева с содержимым из данного дерева. Обычно исходное дерево указывается путем присвоения имени коммиту, ветке или тегу, связанному с ним.

Если не указано, содержимое восстанавливается из *HEAD*, если *--staged* указано, иначе из индекса.

Как частный случай, вы можете использовать *"A...B"* в качестве ярлыка для базы слияния *A и B* если существует ровно одна база слияния. Вы можете опустить не более одного из *A и B*, и в этом случае по умолчанию используется значение *HEAD*.

>*-p*

>*--patch*

В интерактивном режиме выберите фрагменты в разнице между источником восстановления и местом восстановления.

Обратите внимание, что *--patch* не может принимать пути и предложит восстановить все измененные пути.

>*-W*

>*--worktree*

>*-S*

>*--staged*

Укажите место восстановления. Если ни одна из опций не указана, по умолчанию восстанавливается рабочее дерево. Указание *--staged* приведет только к восстановлению индекса. Указание обоих восстанавливает оба.

>*-q*

>*--quiet*

Тихо, подавляйте сообщения обратной связи. Подразумевает *--no-progress*.

>*--progress*
>*--no-progress*

Статус выполнения сообщается в стандартном потоке ошибок по умолчанию, когда он подключен к терминалу, если *--quiet* не указано иное. Этот флаг включает отчеты о ходе работы, даже если они не подключены к терминалу, независимо от *--quiet*.

>*--ours*

>*--theirs*

При восстановлении файлов в рабочем дереве из индекса используйте этап №2 ( *ours* ) или №3 ( *theirs* ) для неслитных путей.

Обратите внимание, что во время и *git rebase
ours* и *theirs* могут поменяться местами.


По умолчанию, если *--staged* указано, содержимое восстанавливается из *HEAD*, иначе из индекса. Используйте *--source* для восстановления из другого коммита.

Примеры:

Следующая последовательность переключается на *master* ветку, возвращает *Makefile* две ревизии назад, удаляет *hello.c* по ошибке и возвращает его из индекса.

>*git switch master* 

>*git restore --source master~2 Makefile*  

>*rm -f hello.c* 

>*git restore hello.c* 

взять файл из другого коммита

восстановить *hello.c* из индекса

Если вы хотите восстановить все исходные файлы *C*, чтобы они соответствовали версии в индексе, вы можете сказать

>*git restore '*.c'*

Обратите внимание на кавычки вокруг *.c. Файл hello.cтакже будет восстановлен, даже если его больше нет в рабочем дереве, потому что подстановка файлов используется для сопоставления записей в индексе (а не в рабочем дереве оболочкой).

Чтобы восстановить все файлы в текущем каталоге

>*git restore*

или восстановить все рабочие файлы дерева с помощью магии *top pathspec*

>*git restore :/*

Чтобы восстановить файл в индексе, чтобы он соответствовал версии в HEAD(это то же самое, что использовать *git-reset(1)* )

>*git restore --staged hello.c*

или вы можете восстановить как индекс, так и рабочее дерево (это то же самое, что использовать *git-checkout(1)* )

>*git restore --source=HEAD --staged --worktree hello.c*

или короткая форма, которая более практична, но менее удобочитаема:

>*git restore -s@ -SW hello.c*

## Слияние веток и решение конфликтов

Команда для выкачивания информации из ветки branch_name в текущую ветку:

>git merge branch_name

Для того что бы решить merge конфликт, нужно убрать лишние строки и отредактировать текст


## Справка

Что бы вызвать справку для какой-то команды, нужно добавить тег:

>--help

Примеры:

1. *git add --help*
2. *git commit --help*
3. *git commit --help*


## Создание таблицы

Столбец_1|Столбец_2|Столбец_3
---|---|---
Данные_1|Данные_2|Данные_3
Данные_1|Данные_2|Данные_3
